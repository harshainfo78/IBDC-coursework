{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Linux &amp; HPC: A Quick Guided Tour","text":""},{"location":"#syllabus-overview","title":"Syllabus Overview","text":"<ul> <li>Introduction</li> <li>Importance of Linux</li> <li>Architecture of Linux</li> <li>The Terminal</li> <li>Linux File Hierarchy Structure</li> <li>The Linux Shell</li> <li>Navigating the filesystem</li> <li>File Operations</li> </ul>"},{"location":"#introduction","title":"Introduction","text":"<p>With the avant-garde technologies and constant evolution of scientific knowledge, biologists are faced with an increasing need for bioinformatics skills to deal with high-throughput data storage, retrieval, and analysis. Although several resources developed for such tasks have a graphical user interface, many operations can be more efficiently handled with command-line programs and utilities.</p> <p>The Linux shell is both a command-line interface (CLI) and a scripting language, allowing tasks to be done automatically and quickly. With the proper commands, the shell can repeat tasks with or without some modification as many times as we want.</p> <p>Linux is a family of free and open-source operating systems based on the Linux kernel. The Linux Kernel is like the brain of the operating system because it manages how the computer interacts with its hardware and resources. But the Linux Kernel alone is not enough to make a complete operating system. </p> <p>To create a full and functional system, the Linux Kernel is combined with a collection of software packages and utilities, which are together called Linux distributions. These distributions make the Linux Operating System ready for users to run their applications and perform tasks on their computers securely and effectively. Operating systems based on Linux are known as Linux distributions or distros. </p>"},{"location":"#examples-of-distributions","title":"Examples of Distributions","text":"<ul> <li>Debian</li> <li>Ubuntu</li> <li>Fedora</li> <li>CentOS</li> <li>Gentoo</li> <li>Arch Linux</li> <li>Red Hat Enterprise Linux (RHEL)</li> </ul>"},{"location":"#a-brief-history-of-linux","title":"A Brief History of Linux","text":"<p>Linux is an operating system that evolved from a kernel created by Linus Torvalds when he was a student at the University of Helsinki in 1991. </p> <p>When Linus Torvalds was studying at the University of Helsinki, he was using a version of the UNIX operating system called 'Minix'. Linus and other users sent requests for modifications and improvements to Minix's creator, Andrew Tanenbaum, but he felt that they weren't necessary. That's when Linus decided to create his own operating system that would take into account users' comments and suggestions for improvements. </p>"},{"location":"#importance-of-linux","title":"Importance of Linux","text":"<p>Linux is a free, open-source operating system known for its flexibility, stability, and strong security. It is widely used in personal computing, server environments, and enterprise systems because of its performance and customization capabilities.</p> <ul> <li>Security: Offers high security and stability, making it ideal for servers and development work.</li> <li>Open Source: Fully open-source and free to use, modify, and distribute.</li> <li>Flexibility: Highly flexible and customizable to suit different user and industry needs.</li> <li>Community: Supported by a large global community and a vast software ecosystem.</li> </ul>"},{"location":"#architecture-of-linux","title":"Architecture of Linux","text":"<p>Linux architecture refers to the layered structure of the Linux operating system that defines how its components - such as the kernel, shell, system libraries, and hardware interact with each other to manage system resources and execute user programs efficiently.</p> Layer Function Hardware Physical components like CPU, RAM, and Disk. Kernel Core of the OS; manages hardware communication. Shell Interface that interprets commands for the Kernel. Utilities Software and tools that provide OS functionality. <p></p>"},{"location":"#deep-dive-into-linux-architecture","title":"Deep Dive into Linux Architecture","text":""},{"location":"#1-kernel","title":"1. Kernel","text":"<p>The kernel is the core of the Linux operating system that manages hardware resources and controls communication between software and hardware.  * Management: Handles process management, memory, and device control. * Security: Prevents conflicts between multiple running programs.</p>"},{"location":"#2-system-libraries","title":"2. System Libraries","text":"<p>System libraries provide essential functions that allow applications to interact with the kernel without needing to access it directly.  * Efficiency: These libraries contain pre-written code that applications can use to perform specific tasks, saving developers time and effort. * Interface: They act as a bridge between applications and the kernel, providing a standardized and efficient way to interact with the underlying system.</p>"},{"location":"#3-shell","title":"3. Shell","text":"<p>The shell is the command-line interface that allows users to communicate with the operating system by entering commands.  * Bridge: It interprets and executes user commands, forwarding requests to the kernel for processing. * Utility: Provides a convenient way to run programs, manage files, and configure the system.</p>"},{"location":"#4-hardware-layer","title":"4. Hardware Layer","text":"<p>The hardware layer consists of physical components that execute commands and provide system resources.  * Components: Includes RAM (Random Access Memory), HDD (Hard Disk Drive), CPU (Central Processing Unit), and I/O devices. * Interaction: The Linux kernel and system libraries enable communication and control over these components, ensuring they work harmoniously.</p>"},{"location":"#5-system-utility","title":"5. System Utility","text":"<p>System utilities are essential tools and programs provided by the Operating System to manage and configure various aspects of the system.  * Administrative Tasks: Installing software, configuring network settings, and monitoring system performance. * Management: Managing users and file permissions to maintain system efficiency.</p>"},{"location":"#the-terminal","title":"The Terminal","text":"<p>While the terms \"terminal,\" \"shell,\" and \"command line interface\" are often used interchangeably, there are subtle differences:</p> <p>!!! info \"Defining the Workspace\"     * Terminal: An input and output environment that presents a text-only window running a shell.     * Shell: A program that exposes the computer\u2019s operating system to a user or program (a command line interpreter).     * Command Line Interface (CLI): The user interface managed by the shell which processes commands and outputs results.</p> <p>In the context of Linux, \"opening a terminal\" generally refers to the environment where you run commands and see the results printed out.</p> <p>The terminal is interactive: users can specify commands to run and the terminal outputs the results of those commands. To execute any command, users need to type it into the prompt and press ENTER.</p> <p>When accessing a cloud server, most often it is accessed through a terminal shell. Although personal computers that run Linux often come with the kind of graphical desktop environment familiar to most computer users, it is often more efficient or practical to perform certain tasks through commands entered into the terminal.</p>"},{"location":"#linux-file-hierarchy-structure","title":"Linux File Hierarchy Structure","text":"<p>The Linux File Hierarchy Structure or the Filesystem Hierarchy Standard (FHS) defines the directory structure and directory contents in Unix-like operating systems. It is maintained by the Linux Foundation. Nearly all Linux distributions are compliant with this universal standard filesystem directory structure. The FHS defines a set of directories, each of which serve their own special function.</p> <p>The forward slash (/) is used to indicate the root directory in the filesystem hierarchy defined by the FHS, all files and directories appear under the root directory /, even if they are stored on different physical or virtual devices.</p> <p>When a user logs in to the shell, they are brought to their own user directory, stored within /home/. This is referred to as the user\u2019s home directory. The FHS defines /home/ as containing the home directories for regular users.</p> <p>The root user has its own home directory specified by the FHS: /root/. Note that / is referred to as the \u201croot directory\u201d, and that it is different from root/, which is stored within /.</p> <p>Because the FHS is the default filesystem layout on Linux machines, and each directory within it is included to serve a specific purpose, it simplifies the process of organizing files by their function. The following is a listing of common directories that are directly under the root (/) directory:</p> Directory Description <code>/bin</code> important binary applications <code>/boot</code> boot configuration files, kernels, and other files needed at boot time. <code>/dev</code> System device files. <code>/etc</code> configuration files, startup scripts, etc. <code>/home</code> List of home directories for different users <code>/lib</code> system libraries, shared libraries <code>/lost+found</code> a lost+found system for files that exist under the root (/) directory <code>/media</code> automatically mounted (loaded) partitions on your hard drive and removable media such as CDs, digital cameras, etc. <code>/mnt</code> manually mounted filesystems on your hard drive <code>/opt</code> 3rd part applications to be installed <code>/proc</code> Maintains information about the state of the system, including currently running processes. <code>/root</code> root user's home directory. <code>/sbin</code> important system binaries <code>/srv</code> contain files that are served to other systems <code>/sys</code> system files <code>/tmp</code> temporary files <code>/usr</code> applications and files that are mostly available for all users to access <code>/var</code> variable files such as logs and databases"},{"location":"#the-linux-shell","title":"The Linux Shell","text":""},{"location":"#running-commands","title":"Running Commands","text":"<p>When the shell is first opened, you are presented with a prompt, indicating that the shell is waiting for input. A typical prompt on Linux may look like this: </p> <p><code>username@hostname:~$</code></p> <ul> <li>username represents the username of the current user.</li> <li>hostname represents the name of the computer or system.</li> <li>~ represents the current directory (in this case, the home directory).</li> <li>$ is the command prompt symbol, indicating that the shell is ready to accept commands.</li> </ul> <p>After you type a command, you have to press the Enter \u21b2 key to execute it. So let\u2019s try our first command, <code>ls</code> which is short for \u201clisting\u201d. This command will list the contents of the current directory.</p>"},{"location":"#command-options","title":"Command Options","text":"<p>Commands can often change their behaviour with additional options. Consider the command below as a general example, which we will dissect into its component parts: <code>ls  -l  --sort  time  Documents/</code></p> <ul> <li>ls is the command.</li> <li>-l is an argument that \u201cswitches on\u201d a particular behaviour of the program. In this case it lists the files in a \u201clong\u201d format. These kind of arguments are also called an option, switch or flag. Options either start with a single dash (<code>-</code>) or two dashes (<code>--</code>).</li> <li>--sort is also an argument, but it needs a value to indicate how it should change the behaviour of the program. In this case, the option changes how the files are sorted (in our example we specified \u2018time\u2019 to sort files by the time they were created or modified).</li> <li>Documents is a positional argument, which comes at the end of the command. This argument tells the command what to operate on (e.g. files and directories).</li> </ul> <p>A command can be called with more than one option and more than one argument: but a command doesn\u2019t always require an argument or an option.</p> <p>Each part is separated by spaces: if you omit the space between <code>ls</code> and <code>-l</code> the shell will look for a command called <code>ls-l</code>, which doesn\u2019t exist. Also, capitalisation can be important: <code>ls -r</code> is different to <code>ls -R</code>.</p> <p>So, our command above gives us a long listing of files and directories in the directory <code>Documents</code>.</p>"},{"location":"#getting-help","title":"Getting help","text":"<p><code>ls</code> has lots of other options. There are two common ways to find out how to use a command and what options it accepts:</p> <ol> <li>We can pass a <code>--help</code> option to the command, such as <code>ls --help</code>.</li> <li>We can read its manual with <code>man</code>, such as <code>man ls</code>. To exit the man page you can type <code>q</code> (for \u201cquit\u201d).</li> </ol>"},{"location":"#summary","title":"Summary","text":"<ul> <li>The Linux shell (command line) allows running complex operations with a few commands, interacting with high-performance computing servers, and writing reproducible analysis in scripts.</li> <li>The basic syntax of a command is: <code>command -options argument</code>.</li> <li>For example: <code>ls -l Documents</code> would list the contents of the Documents directory in a long format.</li> <li>To find the options available with a given program, we can use the <code>--help</code> function or (in some cases) the <code>man</code> command. </li> <li>For example: <code>ls --help</code> or <code>man ls</code>.</li> </ul>"},{"location":"#2-navigating-the-filesystem","title":"2. Navigating the filesystem","text":""},{"location":"#learning-objectives","title":"Learning Objectives","text":"<ul> <li>Understand the hierarchical structure of filesystems and how the location of files and directories is specified.</li> <li>Distinguish between absolute and relative paths.</li> <li>Recognise when / is used to specify the root directory or to separate directories.</li> <li>Navigate the filesystem using the commands <code>pwd</code>, <code>ls</code> and <code>cd</code>.</li> <li>Make use of the <code>*</code> wildcard to match files by patterns.</li> <li>Use the <code>find</code> command to effectively search for files or directories.</li> </ul>"},{"location":"#linux-filesystem","title":"Linux Filesystem","text":"<p>The part of the operating system responsible for managing files and directories is called the filesystem. It organizes our data into files and directories (also called folders), which hold files or other directories. These directories are organised in a hierarchical way, which we can represent as a tree.</p> <p>This is illustrating the location of the home directories for three users called \u201cibdc\u201d, \u201crcb\u201d and \u201cucsd\u201d. We can see that each of their home directories is within another directory called home. And finally, the home directory is located in the root of the filesystem, represented by a / slash. The root is the top-most directory where everything for our operating system is stored in (it\u2019s not possible to go \u201cabove\u201d this special root directory).</p> <p>When we use the shell, we need to specify the location of files and directories using an \u201caddress\u201d (similarly to how you specify an internet address to reach a given website). Let\u2019s explore this from our shell terminal.</p> <p>First let\u2019s find out where we are by running a command called pwd (which stands for \u201cprint working directory\u201d). Directories are like places - at any time while we are using the shell we are in exactly one place, called our current working directory. Commands mostly read and write files in the current working directory, so knowing where you are before running a command is important.</p> <p>```bash pwd /home/ibdc</p> <p>Here, the computer\u2019s response is /home/ibdc, which is the home directory, the default when opening a new shell terminal. The name \u201cibdc\u201d is the username. If the user \u201crcb\u201d was logged in, they would see /home/rcb as their default working directory. Notice how the location of this folder is specified: / at the start specifies the root of the filesystem. home specifies the folder \u201chome\u201d within the root. / is a separator between the \u201chome\u201d folder and the next folder.</p> <p>The way of representing file or directory locations is called a path. The / slash - Notice that there are two meanings for the / character. When it appears at the beginning of a file or directory name, it refers to the root directory. When it appears inside a name, it\u2019s a separator. Home directory variation - The home directory path will look different on different operating systems. For a user named \u201cucsd\u201d, on a Mac it would look like /Users/ucsd, and on Windows C:\\Users\\ucsd. Listing files: We can see the content of our current directory by running ls, which stands for \u201clisting\u201d:</p> <p>Changing Directory: The command to change locations is cd (\u201cchange directory\u201d) followed by a directory name to change our working directory. cd /home/ibdc/data We can check with pwd that we are in the correct directory. We can also run ls again to see the files within our current directory. There are two ways to specify directory names: An absolute path includes the entire path (or location) from the root directory, which is indicated by a leading slash. The leading / tells the computer to follow the path from the root of the filesystem, so it always refers to exactly one directory, no matter where we are when we run the command. A relative path tries to find that location from where we are (our current directory), rather than from the root of the filesystem. The shell interprets the character ~ (tilde) at the start of a path to mean \u201cthe user\u2019s home directory\u201d. In our example the ~ is equivalent to /home/ibdc. We now know how to go down the directory tree, but how do we go up? cd can only see sub-directories inside your current directory. To move up one directory we need to use the special shortcut .. like this: cd ..</p> <p>Wildcards: Wildcards are special characters that can be used to access multiple files at once. The most commonly-used wildcard is *, which is used to match zero or more characters.</p> <p>.pdb matches every file that ends with \u2018.pdb\u2019 extension. Another common wildcard is ?, which matches any character exactly once. Finding Files: Often, it\u2019s useful to be able to find files that have a particular pattern in their name. We can use the find command to achieve this. Here is an example, where we try to find all the text files that exist in the working folder: find . -type f -name \".txt\" In this case, we used the option -type f to only find files with the given name. We could use the option -type d if we wanted to instead find directories only. If we wanted to find both files and directories, then we can omit this option. We used -name to specify the name of the file we wanted to search for. Similarly to ls, you can use the * wildcard to match any number of characters. In our example, we used .txt to find all files with the .txt file extension. Finally, we searched for files from the current location we were in. That\u2019s what the . in the command above means: search for files from the current directory. If we wanted to find files in a different directory without having to cd into it first, we could replace . with the name/path of the directory we want to search from.  One option that can sometimes be useful is to find and delete all the files. For example, the following command would delete all files with .txt extension: find . -type f -name \".txt\" -delete As you can imagine, this feature is very useful but also potentially dangerous as you may accidentally delete files you didn\u2019t intend to. So, always make sure to run the command without the -delete option first to check that only the files you really want to delete are being matched.</p>"},{"location":"#summary_1","title":"Summary","text":"<ul> <li>The filesystem is organised in a hierarchical way.</li> <li>Every user has a home directory, which on Linux is <code>/home/username/</code>.</li> <li>Locations in the filesystem are represented by a path:<ul> <li>The <code>/</code> used at the start of a path means the \u201croot\u201d directory (the start of the filesystem).</li> <li><code>/</code> used in the middle of the path separates different directories.</li> </ul> </li> <li>Some of the commands used to navigate the filesystem are:<ul> <li><code>pwd</code> to print the working directory (or the current directory)</li> <li><code>ls</code> to list files and directories</li> <li><code>cd</code> to change directory</li> </ul> </li> <li>Directories can be created with the <code>mkdir</code> command.</li> <li>Files can be moved and/or renamed using the <code>mv</code> command.</li> <li>Files can be copied with the <code>cp</code> command. To copy an entire directory (and its contents) we need to use <code>cp -r</code> (the <code>-r</code> option will copy files recursively).</li> <li>Files can be removed with the <code>rm</code> command. To remove an entire directory (and its contents) we need to use <code>rm -r</code> (the <code>-r</code> option will remove files recursively).</li> <li>Deleting files from the command line is permanent.</li> <li>We can operate on multiple files using the <code>*</code> wildcard, which matches \u201czero or more characters\u201d. For example <code>ls *.txt</code> would list all files that have a <code>.txt</code> file extension.</li> <li>The <code>find</code> command can be used to find the location of files matching a specific name pattern.</li> </ul>"},{"location":"#3-file-operations","title":"3. File Operations","text":""},{"location":"#learning-objectives_1","title":"Learning Objectives","text":"<ul> <li>Distinguish between copying and moving files.</li> <li>Recognise how accidental and irreversible data loss may occur when moving or copying files.</li> <li>Create, move, copy and remove files and directories using the commands <code>mkdir</code>, <code>mv</code>, <code>cp</code>, <code>rm</code> and <code>rmdir</code>.</li> </ul>"},{"location":"#creating-directories","title":"Creating directories","text":"<p>We now know how to explore files and directories, but how do we create them in the first place? First, we should see where we are and what we already have. Let\u2019s go to one directory and use <code>ls</code> to see what it contains:</p> <p>```bash cd ~/ibdc_workshop/working_files/ ls</p> <p>Now, let\u2019s create a new directory called test_files using the command mkdir (\u201cmake directory\u201d): Bash mkdir test_files</p> <p>The new directory is created in the current working directory and use ls to see the contents. Note that using the shell to create a directory is no different than using a file explorer. If you open the current directory using your operating system\u2019s graphical file explorer, the results directory will appear there too. While the shell and the file explorer are two different ways of interacting with the files, the files and directories themselves are the same.</p> <p>Markdown</p>"},{"location":"#good-naming-conventions-in-linux","title":"Good naming conventions in linux","text":"<p>Complicated names of files and directories can make your life painful when working on the command line. Here are some useful tips for naming your files:</p> <ul> <li>Don\u2019t use spaces.   Spaces can make a name more meaningful, but since spaces are used to separate arguments on the command line it is better to avoid them in names of files and directories. You can use - or _ instead (e.g. <code>test_files/</code> rather than <code>test files/</code>).</li> <li>Don\u2019t begin the name with - (dash).   Commands treat names starting with - as options.</li> <li>Only use letters, numbers, . period, - hyphen and _ underscore.   Many other characters (such as !, @, $, \", etc.) have special meanings on the command line and can cause your command to not work as expected or even lead to data loss.</li> <li>If you need to refer to names of files or directories that have spaces or other special characters, you should surround the name in quotes (\" \").</li> </ul>"},{"location":"#moving-renaming","title":"Moving &amp; Renaming","text":"<p>In our <code>~/ibdc-workshop/test_data/</code> directory we have a file called <code>6M0J.pdb</code>, which is a crystal structure file of SARS-CoV-2 spike receptor-binding domain bound with human ACE2 protein. Let\u2019s move this file to the <code>working_data/</code> directory we created earlier, using the command <code>mv</code> (\u201cmove\u201d):</p> <p>```bash mv 6M0J.pdb ../working_data/</p> <p>The first argument tells mv what we\u2019re \u201cmoving\u201d, while the second is where it\u2019s to go. In this case, we\u2019re moving 6M0J.pdb to working_data/. We can check the file has moved there: Bash ls ../working_data/</p> <p>If this is not an informative name for our file we can change the name by using the mv command. Here\u2019s how we could change a file\u2019s name: Bash mv ../working_data/6M0J.pdb ../working_data/Spike-RBD_6M0J.pdb</p> <p>In this case, we are \u201cmoving\u201d the file to the same place but with a different name. Be careful when specifying the target file name, since mv will silently overwrite any existing file with the same name, which could lead to data loss. The command mv also works with directories, and you can use it to move/rename an entire directory just as you use it to move an individual file.</p> <p>Copying Files and Directories The cp command works very much like mv, except it copies a file instead of moving it. For example, let\u2019s make a copy of our .pdb file: Bash cp ~/ibdc-workshop/working_data/Spike-RBD_6M0J.pdb 6M0J_copy.pdb</p> <p>Copy a File: cp source_file.txt destination_file.txt Copy File to Directory: cp file.txt /path/to/folder/ Copy Directory (Recursive): cp -r source_dir destination_dir Copy Multiple Files: cp file1.txt file2.txt /destination/folder/ Preserve Attributes: cp -a source/ destination/ (preserves structure, permissions, and timestamps) Verbose Mode: cp -v (shows files as they are copied) Prompt Before Overwriting: cp -i Copying within the same directory: cp file.txt file_copy.txt Copying to a different directory: cp file.txt /home/user/documents/ Copying the contents of a folder: cp -r dir1/* dir2/</p> <p>Removing Files and Directories The Unix command used to remove or delete files is rm (\u201cremove\u201d). For example, let\u2019s remove one of the files we copied earlier: Bash rm 6M0J_copy.pdb</p> <p>We can confirm the file is gone using ls. What if we try to remove the whole test_dir/ directory we created earlier: Bash rm test_dir/</p>"},{"location":"#rm-cannot-remove-test_dir-is-a-directory","title":"rm: cannot remove 'test_dir/': Is a directory","text":"<p>We get an error. This happens because rm by default only works on files, not directories. rm can remove a directory and all its contents if we use the recursive option -r, and it will do so without any confirmation prompts: Bash rm -r test_dir/</p> <p>Given that there is no way to retrieve files deleted using the shell, rm -r should be used with great caution (you might consider adding the interactive option rm -r -i). To remove empty directories, we can also use the rmdir command. This is a safer option than rm -r, because it will never delete the directory if it contains files, giving us a chance to check whether we really want to delete all its contents.</p>"},{"location":"#summary_2","title":"Summary","text":"<ul> <li>Directories can be created with the <code>mkdir</code> command.</li> <li>Files can be moved and/or renamed using the <code>mv</code> command.</li> <li>Data loss warning: If files of the same name exist in the destination, they will be overwritten.</li> <li>Files can be copied with the <code>cp</code> command.</li> <li>To copy an entire directory (and its contents) we need to use <code>cp -r</code> (the <code>-r</code> option will copy files recursively).</li> <li>Data loss warning: If files of the same name exist in the destination, they will be overwritten.</li> <li>Files can be removed with the <code>rm</code> command. To remove an entire directory (and its contents) we need to use <code>rm -r</code> (the <code>-r</code> option will remove files recursively).</li> <li>Data loss warning: Deleting files from the command line is permanent.</li> </ul>"},{"location":"#linux-command-reference","title":"Linux Command Reference","text":""},{"location":"#file-commands","title":"File Commands","text":"# Command Description 1 <code>ls</code> Directory listing 2 <code>ls -al</code> Formatted listing with hidden files 3 <code>ls -lt</code> Sorting the Formatted listing by time modification 4 <code>ls -ltr</code> Shows the files in the long listing format in reverse sorted by modification time 5 <code>cd &lt;dir&gt;</code> Change directory to dir 6 <code>cd</code> Change to home directory 7 <code>pwd</code> Show current working directory 8 <code>mkdir &lt;dir&gt;</code> Creating a directory dir 9 <code>cat</code> Display the content of a file, copy content from one file to another, or concatenate multiple files 10 <code>more</code> View the contents of a file one screen at a time (permits forward scrolling) 11 <code>less</code> View the contents of a file one screen at a time (forward and backward navigation) 12 <code>head</code> Output the first 10 lines of the file 13 <code>tail</code> Output the last 10 lines of the file 14 <code>tail -f &lt;file&gt;</code> Output the contents of file as it grows, starting with the last 10 lines 15 <code>touch</code> Create or update file 16 <code>rm</code> Deleting the file 17 <code>rm -r</code> Deleting the directory 18 <code>rm -f</code> Force to remove the file 19 <code>rm -rf</code> Force to remove the directory 20 <code>cp</code> Copy the file 21 <code>cp -r</code> Copy the entire directory 22 <code>mv</code> Rename or moving file"},{"location":"#process-management","title":"Process Management","text":"# Command Description 1 <code>ps</code> To display the currently working processes 2 <code>top</code> Display all running process 3 <code>kill &lt;pid&gt;</code> Kill the process with given pid 4 <code>pkill &lt;pattern&gt;</code> Will kill all processes matching the pattern 5 <code>bg</code> List stopped or background jobs; resume a stopped job in the background 6 <code>fg</code> Brings the most recent job to foreground"},{"location":"#file-permission","title":"File Permission","text":"Command Description <code>chmod</code> Change the permission of file to octal. Sum values for User, Group, and World: \u2022 4 - read (r) \u2022 2 - write (w) \u2022 1 - execute (x)"},{"location":"#searching","title":"Searching","text":"# Command Description 1 <code>grep &lt;pattern&gt; &lt;file&gt;</code> Search for pattern in file 2 <code>grep -r &lt;pattern&gt; &lt;dir&gt;</code> Search recursively for pattern in dir 3 <code>command \\| grep &lt;pattern&gt;</code> Search pattern in the output of a command 4 <code>pgrep &lt;pattern&gt;</code> Searches for all named processes matching the pattern and returns their ID 5 <code>locate &lt;file&gt;</code> Find all instances of file"},{"location":"#system-info","title":"System Info","text":"# Command Description 1 <code>date</code> Show the current date and time 2 <code>cal</code> Show the present month's calendar 3 <code>uptime</code> Show current uptime 4 <code>w</code> Display who is online 5 <code>whoami</code> Who you are logged in as 6 <code>finger &lt;user&gt;</code> Display information about user 7 <code>uname -a</code> Show kernel information 8 <code>cat /proc/cpuinfo</code> CPU information 9 <code>man &lt;command&gt;</code> Show the manual for command 10 <code>df -h</code> Show disk usage in human-readable format 11 <code>du -sh</code> Show directory space usage 12 <code>free</code> Show memory and swap usage 13 <code>whereis &lt;tool&gt;</code> Show possible locations of tool 14 <code>which &lt;tool&gt;</code> Show which application will be run by default"},{"location":"#compression","title":"Compression","text":"# Command Description 1 <code>tar cf file.tar file</code> Create tar named file.tar containing file 2 <code>tar xf file.tar</code> Extract the files from file.tar 3 <code>tar czf file.tar.gz files</code> Create a tar with Gzip compression 4 <code>tar xzf file.tar.gz</code> Extract a tar using Gzip 5 <code>tar cjf file.tar.bz2</code> Create tar with Bzip2 compression 6 <code>tar xjf file.tar.bz2</code> Extract a tar using Bzip2 7 <code>gzip file</code> Compresses file and renames it to file.gz 8 <code>gzip -d file.gz</code> Decompresses file.gz back to file"},{"location":"#network","title":"Network","text":"# Command Description 1 <code>ping host</code> Ping host and output results 2 <code>whois domain</code> Get whois information for domains 3 <code>dig domain</code> Get DNS information for domain 4 <code>wget &lt;file&gt;</code> Download file 5 <code>wget -c file</code> Continue a stopped download"},{"location":"#shortcuts","title":"Shortcuts","text":"Shortcut Description <code>Ctrl + C</code> Halts the current command <code>Ctrl + D</code> Logout the current session, similar to exit <code>Ctrl + W</code> Erases one word in the current line <code>Ctrl + U</code> Erases the whole line <code>Ctrl + R</code> Type to bring up a recent command <code>!!</code> Repeats the last command <code>exit</code> Logout the current session"}]}